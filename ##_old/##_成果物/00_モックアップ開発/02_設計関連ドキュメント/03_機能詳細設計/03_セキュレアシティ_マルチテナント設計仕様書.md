# セキュレアシティ スマートコミュニケーションアプリ
## マルチテナント設計仕様書

**文書バージョン:** 1.0  
**作成日:** 2025年10月23日  
**対象:** デモ版からの拡張設計  

---

## 目次

1. [マルチテナント化の目的と戦略](#1-マルチテナント化の目的と戦略)
2. [アーキテクチャ設計](#2-アーキテクチャ設計)
3. [データベース設計](#3-データベース設計)
4. [認証・認可システム](#4-認証認可システム)
5. [データアクセス層](#5-データアクセス層)
6. [機能別のテナント対応](#6-機能別のテナント対応)
7. [テナント管理機能](#7-テナント管理機能)
8. [セキュリティ設計](#8-セキュリティ設計)
9. [パフォーマンス最適化](#9-パフォーマンス最適化)
10. [デプロイとインフラ](#10-デプロイとインフラ)
11. [移行計画](#11-移行計画)
12. [コスト試算](#12-コスト試算)

---

## 1. マルチテナント化の目的と戦略

### 1.1 目的

セキュレアシティ専用アプリから、**複数のマンション・コミュニティで利用可能なSaaSプラットフォーム**へ拡張する。

**期待される効果:**
- ✅ 他のマンション・コミュニティへの横展開が容易
- ✅ 運用コストの最適化（共通インフラの活用）
- ✅ 機能の標準化と品質向上
- ✅ スケールメリットによる開発効率化

### 1.2 採用方式

**Row-Level Multi-Tenancy（行レベル分離）**

```
┌─────────────────────────────────────┐
│     共通データベース (PostgreSQL)     │
├─────────────────────────────────────┤
│ tenant_id | user_id | name | ...    │
├─────────────────────────────────────┤
│     1     | 1001    | 田中 | ...    │ ← セキュレアシティ
│     1     | 1002    | 鈴木 | ...    │ ← セキュレアシティ
│     2     | 2001    | Smith| ...    │ ← マンションA
│     2     | 2002    | Chen | ...    │ ← マンションA
└─────────────────────────────────────┘
```

**選定理由:**
- 小〜中規模のテナント数に最適（目標: 50〜100テナント）
- 単一DBでコスト効率が高い
- メンテナンスが容易
- データ分離とセキュリティを確保可能
- 将来的な分離（DB分割）も可能

**代替案との比較:**

| 方式 | コスト | 分離性 | 保守性 | 適用 |
|------|--------|--------|--------|------|
| **Row-Level** | ◎ 低 | ○ 中 | ◎ 高 | ✅ 採用 |
| Database per Tenant | ✗ 高 | ◎ 高 | ✗ 低 | 不採用 |
| Schema per Tenant | △ 中 | ○ 中 | △ 中 | 不採用 |

---

## 2. アーキテクチャ設計

### 2.1 全体アーキテクチャ

```
┌──────────────────────────────────────────────────────┐
│                   ユーザー端末                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │securea-city │  │ mansion-a   │  │ mansion-b   │  │
│  │.yourapp.com │  │.yourapp.com │  │.yourapp.com │  │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  │
└─────────┼─────────────────┼─────────────────┼─────────┘
          │                 │                 │
          └─────────────────┴─────────────────┘
                            │
                            ▼
          ┌─────────────────────────────────┐
          │   Nginx (Reverse Proxy)         │
          │   - サブドメイン識別             │
          │   - SSL/TLS終端                 │
          └────────────┬────────────────────┘
                       │
                       ▼
          ┌─────────────────────────────────┐
          │   NestJS アプリケーション        │
          │                                 │
          │  ┌──────────────────────────┐  │
          │  │ Tenant Identification    │  │
          │  │ Middleware               │  │
          │  └────────┬─────────────────┘  │
          │           │                     │
          │  ┌────────▼─────────────────┐  │
          │  │ Tenant Isolation         │  │
          │  │ Middleware               │  │
          │  └────────┬─────────────────┘  │
          │           │                     │
          │  ┌────────▼─────────────────┐  │
          │  │ Business Logic Layer     │  │
          │  │ (テナント対応済み)        │  │
          │  └────────┬─────────────────┘  │
          └───────────┼─────────────────────┘
                      │
                      ▼
          ┌─────────────────────────────────┐
          │   PostgreSQL (単一DB)            │
          │   - tenant_id による行分離       │
          │   - RLS的制約（アプリ層）         │
          └─────────────────────────────────┘
```

### 2.2 テナント識別フロー

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Nginx as Nginx
    participant App as NestJS App
    participant Middleware as Tenant Middleware
    participant DB as PostgreSQL

    User->>Nginx: https://securea-city.yourapp.com/api/users
    Nginx->>App: Host: securea-city.yourapp.com
    App->>Middleware: Request処理開始
    Middleware->>DB: SELECT * FROM tenants WHERE subdomain='securea-city'
    DB-->>Middleware: tenant_id = 1
    Middleware->>Middleware: request.tenant = { id: 1, ... }
    Middleware->>App: 次の処理へ
    App->>DB: SELECT * FROM users WHERE tenant_id = 1
    DB-->>App: テナント1のユーザー一覧
    App-->>User: レスポンス
```

---

## 3. データベース設計

### 3.1 新規テーブル

#### 3.1.1 tenants テーブル

テナント（マンション・コミュニティ）の基本情報を管理。

```sql
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,                    -- テナント名（例: セキュレアシティ）
    subdomain VARCHAR(100) NOT NULL UNIQUE,        -- サブドメイン（例: securea-city）
    domain VARCHAR(255),                           -- 独自ドメイン（オプション）
    plan_type VARCHAR(50) NOT NULL DEFAULT 'FREE', -- FREE/BASIC/PREMIUM
    max_users INTEGER NOT NULL DEFAULT 100,        -- ユーザー数上限
    settings JSONB NOT NULL DEFAULT '{}',          -- テナント固有設定
    is_active BOOLEAN NOT NULL DEFAULT true,       -- 有効/無効
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_tenants_subdomain ON tenants(subdomain);
CREATE INDEX idx_tenants_domain ON tenants(domain) WHERE domain IS NOT NULL;
CREATE INDEX idx_tenants_is_active ON tenants(is_active);
```

**settings (JSONB) の構造例:**
```json
{
  "logo_url": "https://cdn.example.com/logos/securea-city.png",
  "primary_color": "#6366f1",
  "secondary_color": "#8b5cf6",
  "default_language": "JP",
  "timezone": "Asia/Tokyo",
  "contact_email": "admin@securea-city.jp",
  "features_enabled": ["bbs", "parking", "announcement", "survey"]
}
```

#### 3.1.2 tenant_features テーブル

テナントごとに有効化する機能と、その詳細設定を管理。

```sql
CREATE TABLE tenant_features (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    feature_name VARCHAR(100) NOT NULL,            -- 'bbs', 'parking', 'survey' 等
    is_enabled BOOLEAN NOT NULL DEFAULT true,
    config JSONB NOT NULL DEFAULT '{}',            -- 機能固有の設定
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    UNIQUE(tenant_id, feature_name)
);

CREATE INDEX idx_tenant_features_tenant_id ON tenant_features(tenant_id);
```

**config (JSONB) の例 - 駐車場機能:**
```json
{
  "price_per_day": 100,
  "max_consecutive_days": 3,
  "allow_multiple_same_day": false,
  "booking_advance_days": 30,
  "parking_spaces": [
    { "id": "F1", "name": "表側1番", "available": true },
    { "id": "F2", "name": "表側2番", "available": true }
  ]
}
```

#### 3.1.3 parking_spaces テーブル

テナントごとの駐車場情報を管理（駐車場数・配置はテナントによって異なる）。

```sql
CREATE TABLE parking_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    space_id VARCHAR(20) NOT NULL,                 -- F1, F2, B1, B2 等
    display_name VARCHAR(100) NOT NULL,            -- 表示名
    location_type VARCHAR(50) NOT NULL,            -- 'front' / 'back'
    position_data JSONB,                           -- マップ上の座標等
    is_available BOOLEAN NOT NULL DEFAULT true,
    notes TEXT,                                    -- 備考（大型車可、等）
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    UNIQUE(tenant_id, space_id)
);

CREATE INDEX idx_parking_spaces_tenant_id ON parking_spaces(tenant_id);
```

### 3.2 既存テーブルの拡張

すべての主要テーブルに `tenant_id` カラムを追加。

#### 3.2.1 users テーブル

```sql
ALTER TABLE users 
    ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- 複合ユニーク制約: 同じメールアドレスでもテナントが違えば別ユーザー
CREATE UNIQUE INDEX idx_users_tenant_email ON users(tenant_id, email);

-- パフォーマンス向上のための複合インデックス
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_tenant_created ON users(tenant_id, created_at DESC);
```

#### 3.2.2 その他のテーブル

以下のテーブルにも同様に `tenant_id` を追加:

```sql
-- 認証関連
ALTER TABLE magic_links ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE sessions ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- お知らせ関連
ALTER TABLE announcements ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE announcement_contents ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- 掲示板関連
ALTER TABLE bbs_threads ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE bbs_comments ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- 駐車場予約関連
ALTER TABLE parking_reservations ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE parking_blocks ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- 通知設定
ALTER TABLE notification_settings ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- 翻訳キャッシュ（NULLを許容: グローバル共有キャッシュのため）
ALTER TABLE translation_cache ADD COLUMN tenant_id UUID REFERENCES tenants(id);

-- 各テーブルにインデックスを追加
CREATE INDEX idx_announcements_tenant_id ON announcements(tenant_id);
CREATE INDEX idx_bbs_threads_tenant_id ON bbs_threads(tenant_id);
CREATE INDEX idx_parking_reservations_tenant_id ON parking_reservations(tenant_id);
-- 以下同様...
```

### 3.3 翻訳マスタの2層構造

翻訳マスタは**グローバル（全テナント共通）**と**テナント固有**の2層構造とする。

```sql
ALTER TABLE translation_master 
    ADD COLUMN tenant_id UUID REFERENCES tenants(id);

-- tenant_id が NULL の場合はグローバル翻訳
-- tenant_id が設定されている場合はテナント固有翻訳

CREATE INDEX idx_translation_master_tenant_key 
    ON translation_master(tenant_id, translation_key);
```

**翻訳取得の優先順位:**
1. テナント固有翻訳を検索
2. なければグローバル翻訳を検索
3. どちらもなければキーをそのまま返す

### 3.4 Prismaスキーマ例

```prisma
// ==================== テナント管理 ====================

model Tenant {
  id              String   @id @default(uuid())
  name            String
  subdomain       String   @unique
  domain          String?
  planType        String   @default("FREE") @map("plan_type")
  maxUsers        Int      @default(100) @map("max_users")
  settings        Json     @default("{}")
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // リレーション
  users           User[]
  announcements   Announcement[]
  bbsThreads      BbsThread[]
  features        TenantFeature[]
  parkingSpaces   ParkingSpace[]

  @@map("tenants")
}

model TenantFeature {
  id          String   @id @default(uuid())
  tenantId    String   @map("tenant_id")
  featureName String   @map("feature_name")
  isEnabled   Boolean  @default(true) @map("is_enabled")
  config      Json     @default("{}")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, featureName])
  @@map("tenant_features")
}

// ==================== ユーザー管理 ====================

model User {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  email           String
  name            String
  language        String   @default("JP")
  role            String   @default("resident")
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  tenant          Tenant   @relation(fields: [tenantId], references: [id])
  
  @@unique([tenantId, email])
  @@index([tenantId])
  @@map("users")
}

// ==================== 駐車場管理 ====================

model ParkingSpace {
  id            String   @id @default(uuid())
  tenantId      String   @map("tenant_id")
  spaceId       String   @map("space_id")
  displayName   String   @map("display_name")
  locationType  String   @map("location_type")
  positionData  Json?    @map("position_data")
  isAvailable   Boolean  @default(true) @map("is_available")
  notes         String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, spaceId])
  @@index([tenantId])
  @@map("parking_spaces")
}

model ParkingReservation {
  id            String   @id @default(uuid())
  tenantId      String   @map("tenant_id")
  userId        String   @map("user_id")
  spaceId       String   @map("space_id")
  reservationDate DateTime @map("reservation_date")
  vehicleNumber String?  @map("vehicle_number")
  status        String   @default("confirmed")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([tenantId, userId])
  @@index([tenantId, reservationDate])
  @@map("parking_reservations")
}

// ==================== 翻訳管理 ====================

model TranslationMaster {
  id              String   @id @default(uuid())
  tenantId        String?  @map("tenant_id")  // NULL = グローバル翻訳
  translationKey  String   @map("translation_key")
  jaText          String   @map("ja_text")
  enText          String   @map("en_text")
  cnText          String   @map("cn_text")
  category        String
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([tenantId, translationKey])
  @@index([tenantId, translationKey])
  @@map("translation_master")
}
```

---

## 4. 認証・認可システム

### 4.1 テナント識別方式

**サブドメイン方式（推奨）**

```
https://securea-city.yourapp.com  → tenant_id: 1
https://mansion-a.yourapp.com     → tenant_id: 2
https://mansion-b.yourapp.com     → tenant_id: 3
```

**独自ドメイン対応（将来）**

```
https://app.securea-city.jp       → tenants.domain で紐付け
```

### 4.2 ログインフロー

```mermaid
sequenceDiagram
    participant U as ユーザー
    participant F as Frontend
    participant A as Auth Service
    participant DB as Database
    participant M as Mail Service

    U->>F: https://securea-city.yourapp.com/login
    F->>A: GET /api/auth/tenant-info (Host Header)
    A->>DB: SELECT * FROM tenants WHERE subdomain='securea-city'
    DB-->>A: tenant情報（logo, color等）
    A-->>F: テナント情報
    F->>F: 画面カスタマイズ（ロゴ、カラー適用）
    
    U->>F: メールアドレス入力
    F->>A: POST /api/auth/request-magic-link
    Note over F,A: { email, tenant_id }
    A->>DB: SELECT * FROM users WHERE tenant_id=1 AND email='...'
    DB-->>A: ユーザー存在確認
    A->>A: マジックリンク生成（tenant_id含む）
    A->>M: メール送信
    M-->>U: マジックリンクメール
    
    U->>U: メール内リンククリック
    U->>A: GET /auth/verify?token=xxx&tenant_id=1
    A->>DB: トークン検証（tenant_id一致確認）
    DB-->>A: 検証OK
    A->>A: JWT発行（tenant_id含む）
    A-->>U: ログイン成功 + JWT
```

### 4.3 JWT構造

```json
{
  "sub": "user-uuid-1234",
  "email": "tanaka@example.com",
  "tenant_id": "tenant-uuid-5678",
  "role": "resident",
  "iat": 1698765432,
  "exp": 1698851832
}
```

### 4.4 認証ミドルウェア

#### TenantIdentificationMiddleware

リクエストからテナントを特定し、`request.tenant` にセット。

```typescript
@Injectable()
export class TenantIdentificationMiddleware implements NestMiddleware {
  constructor(
    private readonly tenantService: TenantService,
    private readonly cacheManager: Cache,
  ) {}

  async use(req: Request, res: Response, next: NextFunction) {
    // 1. サブドメインからテナント識別
    const host = req.get('host'); // securea-city.yourapp.com
    const subdomain = this.extractSubdomain(host);

    // 2. キャッシュ確認（パフォーマンス向上）
    let tenant = await this.cacheManager.get<Tenant>(`tenant:${subdomain}`);

    if (!tenant) {
      // 3. DBから取得
      tenant = await this.tenantService.findBySubdomain(subdomain);
      
      if (!tenant) {
        throw new NotFoundException('Tenant not found');
      }

      if (!tenant.isActive) {
        throw new ForbiddenException('Tenant is inactive');
      }

      // 4. キャッシュに保存（TTL: 5分）
      await this.cacheManager.set(`tenant:${subdomain}`, tenant, 300);
    }

    // 5. リクエストオブジェクトにテナント情報を付与
    req['tenant'] = tenant;
    
    next();
  }

  private extractSubdomain(host: string): string {
    // securea-city.yourapp.com → securea-city
    const parts = host.split('.');
    return parts[0];
  }
}
```

#### TenantValidationGuard

JWTのtenant_idとリクエストのテナントが一致するか検証。

```typescript
@Injectable()
export class TenantValidationGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user; // JWTから取得
    const tenant = request.tenant; // TenantIdentificationMiddlewareから

    if (user.tenant_id !== tenant.id) {
      throw new ForbiddenException('Tenant mismatch');
    }

    return true;
  }
}
```

---

## 5. データアクセス層

### 5.1 Prismaミドルウェア

すべてのクエリに自動的に `tenant_id` フィルタを追加。

```typescript
// prisma.service.ts

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  private currentTenantId: string | null = null;

  async onModuleInit() {
    await this.$connect();
    
    // グローバルミドルウェア: tenant_id フィルタの自動追加
    this.$use(async (params, next) => {
      // tenantsテーブル自体へのクエリは除外
      if (params.model === 'Tenant') {
        return next(params);
      }

      // tenant_id を持つモデルの場合
      const modelsWithTenant = [
        'User',
        'Announcement',
        'BbsThread',
        'BbsComment',
        'ParkingReservation',
        // ... 他のモデル
      ];

      if (modelsWithTenant.includes(params.model)) {
        // SELECT クエリ
        if (params.action === 'findMany' || params.action === 'findFirst' || params.action === 'findUnique') {
          params.args.where = {
            ...params.args.where,
            tenantId: this.currentTenantId,
          };
        }

        // CREATE クエリ
        if (params.action === 'create') {
          params.args.data = {
            ...params.args.data,
            tenantId: this.currentTenantId,
          };
        }

        // UPDATE クエリ
        if (params.action === 'update' || params.action === 'updateMany') {
          params.args.where = {
            ...params.args.where,
            tenantId: this.currentTenantId,
          };
        }

        // DELETE クエリ
        if (params.action === 'delete' || params.action === 'deleteMany') {
          params.args.where = {
            ...params.args.where,
            tenantId: this.currentTenantId,
          };
        }
      }

      return next(params);
    });
  }

  setTenantId(tenantId: string) {
    this.currentTenantId = tenantId;
  }

  clearTenantId() {
    this.currentTenantId = null;
  }
}
```

### 5.2 Tenant-Aware Repository パターン

```typescript
// base-tenant-aware.repository.ts

export abstract class BaseTenantAwareRepository<T> {
  constructor(
    protected readonly prisma: PrismaService,
    private readonly modelName: string,
  ) {}

  protected async findMany(args?: any): Promise<T[]> {
    return this.prisma[this.modelName].findMany({
      ...args,
      where: {
        ...args?.where,
        tenantId: this.prisma['currentTenantId'],
      },
    });
  }

  protected async findUnique(args: any): Promise<T | null> {
    return this.prisma[this.modelName].findUnique({
      ...args,
      where: {
        ...args.where,
        tenantId: this.prisma['currentTenantId'],
      },
    });
  }

  protected async create(data: any): Promise<T> {
    return this.prisma[this.modelName].create({
      data: {
        ...data,
        tenantId: this.prisma['currentTenantId'],
      },
    });
  }

  // update, delete も同様に実装
}
```

**使用例:**

```typescript
// bbs.repository.ts

@Injectable()
export class BbsRepository extends BaseTenantAwareRepository<BbsThread> {
  constructor(prisma: PrismaService) {
    super(prisma, 'bbsThread');
  }

  async findAllThreads(category?: string): Promise<BbsThread[]> {
    // 自動的に tenant_id でフィルタされる
    return this.findMany({
      where: category ? { category } : {},
      orderBy: { createdAt: 'desc' },
    });
  }

  async createThread(data: CreateThreadDto): Promise<BbsThread> {
    // 自動的に tenant_id が追加される
    return this.create(data);
  }
}
```

### 5.3 スーパー管理者用Repository

全テナントのデータにアクセスする必要がある場合。

```typescript
@Injectable()
export class SuperAdminRepository {
  constructor(private readonly prisma: PrismaService) {}

  async getAllTenantsData(): Promise<any[]> {
    // tenant_id フィルタをスキップ
    this.prisma.clearTenantId();
    
    const data = await this.prisma.user.findMany();
    
    return data;
  }
}
```

---

## 6. 機能別のテナント対応

### 6.1 駐車場予約機能

#### 課題
- 駐車場の数・配置はテナントごとに異なる
- 料金、予約ルールもテナント固有

#### 解決策

**1. ParkingSpacesテーブルで管理**

```typescript
// テナント初期化時に駐車場情報を登録
await prisma.parkingSpace.createMany({
  data: [
    { tenantId: 'tenant-1', spaceId: 'F1', displayName: '表側1番', locationType: 'front' },
    { tenantId: 'tenant-1', spaceId: 'F2', displayName: '表側2番', locationType: 'front' },
    // ... F6まで
    { tenantId: 'tenant-1', spaceId: 'B1', displayName: '裏側1番', locationType: 'back' },
    // ... B6まで
  ],
});
```

**2. テナント固有設定を取得**

```typescript
// parking.service.ts

async getReservationConfig(tenantId: string): Promise<ParkingConfig> {
  const feature = await this.prisma.tenantFeature.findUnique({
    where: {
      tenantId_featureName: {
        tenantId,
        featureName: 'parking',
      },
    },
  });

  return feature.config as ParkingConfig;
}

interface ParkingConfig {
  pricePerDay: number;
  maxConsecutiveDays: number;
  allowMultipleSameDay: boolean;
  bookingAdvanceDays: number;
}
```

**3. 予約ロジックに設定を適用**

```typescript
async createReservation(tenantId: string, dto: CreateReservationDto) {
  const config = await this.getReservationConfig(tenantId);

  // ルールチェック
  if (!config.allowMultipleSameDay) {
    const existing = await this.checkSameDayReservation(dto.userId, dto.date);
    if (existing) {
      throw new BadRequestException('同日に複数予約はできません');
    }
  }

  if (dto.consecutiveDays > config.maxConsecutiveDays) {
    throw new BadRequestException(`最大${config.maxConsecutiveDays}日間まで`);
  }

  // 予約作成
  return this.prisma.parkingReservation.create({
    data: {
      tenantId,
      ...dto,
    },
  });
}
```

### 6.2 翻訳機能

#### 2層構造の実装

```typescript
// translation.service.ts

@Injectable()
export class TranslationService {
  constructor(private readonly prisma: PrismaService) {}

  async getTranslation(
    key: string,
    language: string,
    tenantId: string,
  ): Promise<string> {
    // 1. テナント固有翻訳を検索
    const tenantTranslation = await this.prisma.translationMaster.findUnique({
      where: {
        tenantId_translationKey: {
          tenantId,
          translationKey: key,
        },
      },
    });

    if (tenantTranslation) {
      return this.getTextByLanguage(tenantTranslation, language);
    }

    // 2. グローバル翻訳を検索
    const globalTranslation = await this.prisma.translationMaster.findUnique({
      where: {
        tenantId_translationKey: {
          tenantId: null,
          translationKey: key,
        },
      },
    });

    if (globalTranslation) {
      return this.getTextByLanguage(globalTranslation, language);
    }

    // 3. どちらもなければキーをそのまま返す
    return key;
  }

  private getTextByLanguage(translation: TranslationMaster, language: string): string {
    switch (language) {
      case 'JP':
        return translation.jaText;
      case 'EN':
        return translation.enText;
      case 'CN':
        return translation.cnText;
      default:
        return translation.jaText;
    }
  }

  // 全翻訳を取得（フロントエンド初期化用）
  async getAllTranslations(tenantId: string, language: string): Promise<Record<string, string>> {
    // グローバル翻訳
    const globalTranslations = await this.prisma.translationMaster.findMany({
      where: { tenantId: null },
    });

    // テナント固有翻訳
    const tenantTranslations = await this.prisma.translationMaster.findMany({
      where: { tenantId },
    });

    const result: Record<string, string> = {};

    // グローバルを先に追加
    globalTranslations.forEach((t) => {
      result[t.translationKey] = this.getTextByLanguage(t, language);
    });

    // テナント固有で上書き
    tenantTranslations.forEach((t) => {
      result[t.translationKey] = this.getTextByLanguage(t, language);
    });

    return result;
  }
}
```

### 6.3 お知らせ・掲示板

テナントごとに完全に分離されるため、特別な考慮は不要。

```typescript
// announcement.service.ts

async findAll(tenantId: string): Promise<Announcement[]> {
  // Prismaミドルウェアが自動的に tenant_id でフィルタ
  return this.prisma.announcement.findMany({
    orderBy: { publishedAt: 'desc' },
  });
}
```

---

## 7. テナント管理機能

### 7.1 テナント管理API

#### エンドポイント一覧

| メソッド | エンドポイント | 説明 | 権限 |
|---------|---------------|------|------|
| POST | /api/admin/tenants | 新規テナント作成 | スーパー管理者 |
| GET | /api/admin/tenants | テナント一覧取得 | スーパー管理者 |
| GET | /api/admin/tenants/:id | テナント詳細取得 | スーパー管理者 |
| PUT | /api/admin/tenants/:id | テナント情報更新 | スーパー管理者 |
| PUT | /api/admin/tenants/:id/features | 機能設定更新 | スーパー管理者 |
| POST | /api/admin/tenants/:id/initialize | テナント初期化 | スーパー管理者 |
| DELETE | /api/admin/tenants/:id | テナント削除 | スーパー管理者 |

#### 7.1.1 テナント作成API

```typescript
// admin-tenant.controller.ts

@Controller('admin/tenants')
@UseGuards(SuperAdminGuard)
export class AdminTenantController {
  constructor(
    private readonly tenantService: TenantService,
    private readonly provisioningService: TenantProvisioningService,
  ) {}

  @Post()
  async createTenant(@Body() dto: CreateTenantDto) {
    // 1. テナント作成
    const tenant = await this.tenantService.create(dto);

    // 2. 初期化処理
    await this.provisioningService.initializeTenant(tenant.id, dto);

    return tenant;
  }
}
```

**CreateTenantDto:**

```typescript
export class CreateTenantDto {
  name: string;                        // セキュレアシティ
  subdomain: string;                   // securea-city
  planType: 'FREE' | 'BASIC' | 'PREMIUM';
  maxUsers: number;
  adminEmail: string;                  // 初期管理者のメール
  adminName: string;                   // 初期管理者の名前
  settings: {
    logoUrl?: string;
    primaryColor?: string;
    defaultLanguage: 'JP' | 'EN' | 'CN';
    timezone: string;
    contactEmail: string;
  };
  features: {
    bbs: boolean;
    parking: boolean;
    announcement: boolean;
    survey: boolean;
  };
}
```

### 7.2 テナントプロビジョニング

新規テナント作成時の自動初期化処理。

```typescript
// tenant-provisioning.service.ts

@Injectable()
export class TenantProvisioningService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly userService: UserService,
    private readonly mailService: MailService,
  ) {}

  async initializeTenant(tenantId: string, dto: CreateTenantDto): Promise<void> {
    // 1. 初期管理者ユーザーを作成
    const adminUser = await this.userService.create({
      tenantId,
      email: dto.adminEmail,
      name: dto.adminName,
      role: 'admin',
      language: dto.settings.defaultLanguage,
    });

    // 2. グローバル翻訳マスタをコピー（テナント用にカスタマイズ可能にする）
    await this.copyGlobalTranslations(tenantId);

    // 3. 機能設定を作成
    await this.createFeatureConfigs(tenantId, dto);

    // 4. 駐車場機能が有効な場合、デフォルト駐車場を作成
    if (dto.features.parking) {
      await this.createDefaultParkingSpaces(tenantId);
    }

    // 5. サンプルお知らせを作成（オプション）
    await this.createSampleAnnouncement(tenantId);

    // 6. ウェルカムメールを送信
    await this.mailService.sendWelcomeEmail(adminUser, tenantId);
  }

  private async copyGlobalTranslations(tenantId: string): Promise<void> {
    const globalTranslations = await this.prisma.translationMaster.findMany({
      where: { tenantId: null },
    });

    // テナント固有の翻訳マスタとしてコピー
    await this.prisma.translationMaster.createMany({
      data: globalTranslations.map((t) => ({
        tenantId,
        translationKey: t.translationKey,
        jaText: t.jaText,
        enText: t.enText,
        cnText: t.cnText,
        category: t.category,
      })),
    });
  }

  private async createFeatureConfigs(
    tenantId: string,
    dto: CreateTenantDto,
  ): Promise<void> {
    const configs = [];

    if (dto.features.parking) {
      configs.push({
        tenantId,
        featureName: 'parking',
        isEnabled: true,
        config: {
          pricePerDay: 100,
          maxConsecutiveDays: 3,
          allowMultipleSameDay: false,
          bookingAdvanceDays: 30,
        },
      });
    }

    if (dto.features.bbs) {
      configs.push({
        tenantId,
        featureName: 'bbs',
        isEnabled: true,
        config: {
          allowImageUpload: true,
          maxImageSize: 5242880, // 5MB
          moderationEnabled: true,
        },
      });
    }

    // 他の機能も同様に

    await this.prisma.tenantFeature.createMany({ data: configs });
  }

  private async createDefaultParkingSpaces(tenantId: string): Promise<void> {
    const spaces = [];

    // 表側: F1〜F6
    for (let i = 1; i <= 6; i++) {
      spaces.push({
        tenantId,
        spaceId: `F${i}`,
        displayName: `表側${i}番`,
        locationType: 'front',
      });
    }

    // 裏側: B1〜B6
    for (let i = 1; i <= 6; i++) {
      spaces.push({
        tenantId,
        spaceId: `B${i}`,
        displayName: `裏側${i}番`,
        locationType: 'back',
      });
    }

    await this.prisma.parkingSpace.createMany({ data: spaces });
  }

  private async createSampleAnnouncement(tenantId: string): Promise<void> {
    await this.prisma.announcement.create({
      data: {
        tenantId,
        category: 'info',
        publishedAt: new Date(),
        contents: {
          create: [
            {
              tenantId,
              language: 'JP',
              title: 'アプリへようこそ',
              body: 'セキュレアシティのスマートコミュニケーションアプリへようこそ！',
            },
            {
              tenantId,
              language: 'EN',
              title: 'Welcome to the App',
              body: 'Welcome to Securea City Smart Communication App!',
            },
          ],
        },
      },
    });
  }
}
```

---

## 8. セキュリティ設計

### 8.1 データ分離の厳格化

#### Prismaミドルウェアのテスト

```typescript
// prisma-middleware.spec.ts

describe('Prisma Tenant Isolation Middleware', () => {
  let prisma: PrismaService;

  beforeEach(() => {
    prisma = new PrismaService();
    prisma.setTenantId('tenant-1');
  });

  it('should automatically filter by tenant_id on SELECT', async () => {
    const users = await prisma.user.findMany();
    
    // すべてのユーザーが tenant-1 のものであることを確認
    users.forEach((user) => {
      expect(user.tenantId).toBe('tenant-1');
    });
  });

  it('should prevent cross-tenant access', async () => {
    prisma.setTenantId('tenant-1');
    
    // tenant-2 のユーザーを直接取得しようとする
    const user = await prisma.user.findUnique({
      where: { id: 'tenant-2-user-id' },
    });

    // ミドルウェアが tenant_id フィルタを追加するため、取得できない
    expect(user).toBeNull();
  });

  it('should add tenant_id on CREATE', async () => {
    prisma.setTenantId('tenant-1');
    
    const user = await prisma.user.create({
      data: {
        email: 'test@example.com',
        name: 'Test User',
      },
    });

    expect(user.tenantId).toBe('tenant-1');
  });
});
```

### 8.2 JWT改ざん検出

```typescript
// tenant-validation.guard.ts

@Injectable()
export class TenantValidationGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user; // JWTから
    const tenant = request.tenant; // リクエストヘッダーから

    // JWT内のtenant_idとリクエストのテナントが一致するか
    if (user.tenant_id !== tenant.id) {
      // 監査ログに記録
      this.logSecurityIncident({
        type: 'TENANT_MISMATCH',
        userId: user.sub,
        jwtTenantId: user.tenant_id,
        requestTenantId: tenant.id,
        timestamp: new Date(),
        ip: request.ip,
      });

      throw new ForbiddenException('Tenant mismatch detected');
    }

    return true;
  }

  private logSecurityIncident(incident: any): void {
    // 監査ログテーブルに記録
    // 管理者に通知
  }
}
```

### 8.3 レート制限

テナント単位でのレート制限。

```typescript
// tenant-rate-limit.guard.ts

@Injectable()
export class TenantRateLimitGuard implements CanActivate {
  constructor(private readonly redis: RedisService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const tenant = request.tenant;
    const key = `rate_limit:tenant:${tenant.id}`;

    const count = await this.redis.incr(key);

    if (count === 1) {
      // 初回アクセス: TTLを60秒に設定
      await this.redis.expire(key, 60);
    }

    // テナントごとに1分間に1000リクエストまで
    if (count > 1000) {
      throw new TooManyRequestsException('Rate limit exceeded for tenant');
    }

    return true;
  }
}
```

### 8.4 監査ログ

```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    user_id UUID REFERENCES users(id),
    action VARCHAR(100) NOT NULL,              -- 'CREATE_USER', 'DELETE_POST', 等
    resource_type VARCHAR(100),                -- 'User', 'Announcement', 等
    resource_id UUID,
    details JSONB,                             -- 詳細情報
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audit_logs_tenant_id ON audit_logs(tenant_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);
```

**使用例:**

```typescript
await this.auditLogService.log({
  tenantId: tenant.id,
  userId: user.id,
  action: 'DELETE_BBS_POST',
  resourceType: 'BbsThread',
  resourceId: threadId,
  details: { reason: 'inappropriate content' },
  ipAddress: request.ip,
  userAgent: request.headers['user-agent'],
});
```

### 8.5 テナント削除時のデータ処理

```typescript
// tenant.service.ts

async deleteTenant(tenantId: string, options: DeleteOptions): Promise<void> {
  if (options.soft) {
    // 論理削除
    await this.prisma.tenant.update({
      where: { id: tenantId },
      data: { isActive: false, deletedAt: new Date() },
    });
  } else {
    // 物理削除
    // 1. データエクスポート（バックアップ）
    await this.exportTenantData(tenantId);

    // 2. 関連データをすべて削除（CASCADE）
    await this.prisma.tenant.delete({
      where: { id: tenantId },
    });
  }
}

private async exportTenantData(tenantId: string): Promise<void> {
  // すべてのデータをJSON形式でエクスポート
  const data = {
    users: await this.prisma.user.findMany({ where: { tenantId } }),
    announcements: await this.prisma.announcement.findMany({ where: { tenantId } }),
    bbsThreads: await this.prisma.bbsThread.findMany({ where: { tenantId } }),
    // ... 他のデータ
  };

  // S3等に保存
  await this.storageService.upload(
    `tenant-backups/${tenantId}/export-${Date.now()}.json`,
    JSON.stringify(data),
  );
}
```

---

## 9. パフォーマンス最適化

### 9.1 インデックス戦略

```sql
-- 複合インデックス: tenant_id + よく使用されるカラム
CREATE INDEX idx_users_tenant_created ON users(tenant_id, created_at DESC);
CREATE INDEX idx_users_tenant_email ON users(tenant_id, email);
CREATE INDEX idx_announcements_tenant_published ON announcements(tenant_id, published_at DESC);
CREATE INDEX idx_bbs_threads_tenant_category ON bbs_threads(tenant_id, category, created_at DESC);
CREATE INDEX idx_parking_reservations_tenant_date ON parking_reservations(tenant_id, reservation_date);

-- EXPLAIN ANALYZE でクエリパフォーマンスを定期的にチェック
```

### 9.2 キャッシュ戦略

#### Redis キャッシュキー設計

```
tenant:{tenant_id}:user:{user_id}:profile
tenant:{tenant_id}:translations:{language}
tenant:{tenant_id}:announcements:latest
tenant:{tenant_id}:parking:availability:{date}
tenant:{tenant_id}:features
```

**実装例:**

```typescript
// cache.service.ts

@Injectable()
export class CacheService {
  constructor(private readonly redis: RedisService) {}

  async getTenantUserProfile(tenantId: string, userId: string): Promise<User | null> {
    const key = `tenant:${tenantId}:user:${userId}:profile`;
    const cached = await this.redis.get(key);

    if (cached) {
      return JSON.parse(cached);
    }

    return null;
  }

  async setTenantUserProfile(tenantId: string, userId: string, user: User): Promise<void> {
    const key = `tenant:${tenantId}:user:${userId}:profile`;
    await this.redis.set(key, JSON.stringify(user), 'EX', 300); // TTL: 5分
  }

  async invalidateTenantCache(tenantId: string): Promise<void> {
    // テナント関連のキャッシュをすべて削除
    const pattern = `tenant:${tenantId}:*`;
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

### 9.3 Prisma接続プール設定

```typescript
// prisma.service.ts

new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  // 接続プール設定
  // テナント数が増えても対応できるよう調整
  log: ['query', 'info', 'warn', 'error'],
});
```

**.env 設定:**

```env
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?connection_limit=20&pool_timeout=10"
```

### 9.4 N+1問題の回避

```typescript
// ❌ 悪い例: N+1問題が発生
async getBbsThreadsWithComments(tenantId: string) {
  const threads = await this.prisma.bbsThread.findMany({
    where: { tenantId },
  });

  for (const thread of threads) {
    thread.comments = await this.prisma.bbsComment.findMany({
      where: { threadId: thread.id },
    });
  }

  return threads;
}

// ✅ 良い例: includeで一度に取得
async getBbsThreadsWithComments(tenantId: string) {
  return this.prisma.bbsThread.findMany({
    where: { tenantId },
    include: {
      comments: true,
    },
  });
}
```

### 9.5 クエリパフォーマンス監視

```typescript
// prisma-query-logger.middleware.ts

this.$use(async (params, next) => {
  const before = Date.now();
  const result = await next(params);
  const after = Date.now();

  const duration = after - before;

  // スロークエリの検出（1秒以上）
  if (duration > 1000) {
    console.warn(`Slow query detected: ${params.model}.${params.action} (${duration}ms)`);
    
    // 監視サービスに送信（Datadog, Sentry等）
    this.monitoringService.logSlowQuery({
      model: params.model,
      action: params.action,
      duration,
      args: params.args,
    });
  }

  return result;
});
```

---

## 10. デプロイとインフラ

### 10.1 ドメイン設定

#### ワイルドカードDNS

```
# DNS設定例（Route53、Cloudflare等）

*.yourapp.com    A    <サーバーIPアドレス>
```

これにより、以下のすべてのサブドメインがサーバーに向けられる:
- `securea-city.yourapp.com`
- `mansion-a.yourapp.com`
- `mansion-b.yourapp.com`

### 10.2 SSL証明書（Let's Encrypt）

#### ワイルドカード証明書の取得

```bash
# Certbotのインストール
sudo apt-get install certbot

# ワイルドカード証明書の取得（DNS-01チャレンジ）
sudo certbot certonly \
  --manual \
  --preferred-challenges=dns \
  --email admin@yourapp.com \
  --agree-tos \
  -d '*.yourapp.com' \
  -d 'yourapp.com'

# 証明書の自動更新設定
sudo certbot renew --dry-run
```

### 10.3 Nginx設定

```nginx
# /etc/nginx/sites-available/yourapp

server {
    listen 80;
    server_name ~^(?<subdomain>.+)\.yourapp\.com$;
    
    # HTTPSへリダイレクト
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ~^(?<subdomain>.+)\.yourapp\.com$;

    # ワイルドカード証明書
    ssl_certificate /etc/letsencrypt/live/yourapp.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourapp.com/privkey.pem;

    # セキュリティヘッダー
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # NestJSアプリへプロキシ
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # 静的ファイル
    location /assets/ {
        alias /var/www/yourapp/assets/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### 10.4 環境変数

```env
# .env.production

# アプリケーション
NODE_ENV=production
PORT=3000
MULTI_TENANT_MODE=true
BASE_DOMAIN=yourapp.com
ENABLE_CUSTOM_DOMAINS=false

# データベース
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?connection_limit=20&pool_timeout=10"

# Redis（キャッシュ）
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password

# JWT
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=7d

# Google Translation API
GOOGLE_TRANSLATION_API_KEY=your-google-api-key

# メール送信
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password

# 監視
SENTRY_DSN=your-sentry-dsn
```

### 10.5 Docker化（オプション）

```dockerfile
# Dockerfile

FROM node:18-alpine AS builder

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm ci

COPY . .

RUN npx prisma generate
RUN npm run build

FROM node:18-alpine

WORKDIR /app

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/prisma ./prisma
COPY package*.json ./

EXPOSE 3000

CMD ["npm", "run", "start:prod"]
```

```yaml
# docker-compose.yml

version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://postgres:password@db:5432/mydb
      REDIS_HOST: redis
    depends_on:
      - db
      - redis

  db:
    image: postgres:14
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

---

## 11. 移行計画

### 11.1 既存データのマイグレーション

セキュレアシティの既存データをマルチテナント構造に移行。

#### Step 1: マイグレーションスクリプトの作成

```typescript
// migration-to-multitenant.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function migrateToMultiTenant() {
  console.log('Starting migration to multi-tenant...');

  // 1. セキュレアシティテナントを作成
  const tenant = await prisma.tenant.create({
    data: {
      name: 'セキュレアシティ',
      subdomain: 'securea-city',
      planType: 'PREMIUM',
      maxUsers: 500,
      settings: {
        logoUrl: 'https://cdn.example.com/logos/securea-city.png',
        primaryColor: '#6366f1',
        defaultLanguage: 'JP',
        timezone: 'Asia/Tokyo',
        contactEmail: 'admin@securea-city.jp',
        featuresEnabled: ['bbs', 'parking', 'announcement'],
      },
      isActive: true,
    },
  });

  console.log(`Tenant created: ${tenant.id}`);

  // 2. 既存のusersテーブルにtenant_idを追加
  await prisma.$executeRaw`
    ALTER TABLE users ADD COLUMN IF NOT EXISTS tenant_id UUID;
  `;

  await prisma.$executeRaw`
    UPDATE users SET tenant_id = ${tenant.id} WHERE tenant_id IS NULL;
  `;

  await prisma.$executeRaw`
    ALTER TABLE users ALTER COLUMN tenant_id SET NOT NULL;
  `;

  // 3. 他のテーブルも同様に更新
  const tables = [
    'announcements',
    'announcement_contents',
    'bbs_threads',
    'bbs_comments',
    'parking_reservations',
    'parking_blocks',
    'magic_links',
    'sessions',
    'notification_settings',
  ];

  for (const table of tables) {
    await prisma.$executeRaw`
      ALTER TABLE ${table} ADD COLUMN IF NOT EXISTS tenant_id UUID;
    `;

    await prisma.$executeRaw`
      UPDATE ${table} SET tenant_id = ${tenant.id} WHERE tenant_id IS NULL;
    `;

    await prisma.$executeRaw`
      ALTER TABLE ${table} ALTER COLUMN tenant_id SET NOT NULL;
    `;

    console.log(`Table ${table} migrated`);
  }

  // 4. 外部キー制約を追加
  for (const table of tables) {
    await prisma.$executeRaw`
      ALTER TABLE ${table} 
      ADD CONSTRAINT fk_${table}_tenant 
      FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE;
    `;
  }

  // 5. インデックスを作成
  for (const table of tables) {
    await prisma.$executeRaw`
      CREATE INDEX IF NOT EXISTS idx_${table}_tenant_id ON ${table}(tenant_id);
    `;
  }

  console.log('Migration completed successfully!');
}

migrateToMultiTenant()
  .catch((e) => {
    console.error('Migration failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

#### Step 2: ロールバックスクリプト

```typescript
// rollback-multitenant.ts

async function rollbackMultiTenant() {
  console.log('Rolling back multi-tenant migration...');

  const tables = [
    'users',
    'announcements',
    'announcement_contents',
    'bbs_threads',
    'bbs_comments',
    'parking_reservations',
    'parking_blocks',
    'magic_links',
    'sessions',
    'notification_settings',
  ];

  // 1. 外部キー制約を削除
  for (const table of tables) {
    await prisma.$executeRaw`
      ALTER TABLE ${table} DROP CONSTRAINT IF EXISTS fk_${table}_tenant;
    `;
  }

  // 2. tenant_idカラムを削除
  for (const table of tables) {
    await prisma.$executeRaw`
      ALTER TABLE ${table} DROP COLUMN IF EXISTS tenant_id;
    `;
    console.log(`Table ${table} rolled back`);
  }

  // 3. tenantsテーブルを削除
  await prisma.$executeRaw`
    DROP TABLE IF EXISTS tenant_features CASCADE;
  `;

  await prisma.$executeRaw`
    DROP TABLE IF EXISTS tenants CASCADE;
  `;

  console.log('Rollback completed successfully!');
}
```

### 11.2 段階的な移行

#### フェーズ1: 開発環境（Week 1-2）
- マルチテナント対応のコード実装
- Prismaスキーマの拡張
- ミドルウェア実装
- 単体テスト・統合テスト

#### フェーズ2: ステージング環境（Week 3）
- 本番相当のデータでテスト
- パフォーマンステスト
- セキュリティテスト

#### フェーズ3: 本番移行（Week 4）
- メンテナンス時間を設定
- データベースマイグレーション実行
- アプリケーションデプロイ
- 動作確認

### 11.3 リスク管理

| リスク | 影響 | 対策 |
|--------|------|------|
| マイグレーション失敗 | 高 | ロールバックスクリプト準備、フルバックアップ |
| パフォーマンス劣化 | 中 | インデックス追加、キャッシュ活用 |
| クロステナントアクセス | 高 | ミドルウェアの厳格なテスト |
| ダウンタイム | 中 | メンテナンス時間帯の選定、Blue-Greenデプロイ |

---

## 12. コスト試算

### 12.1 インフラコスト比較

#### 単一テナント（現在）

| 項目 | 月額 |
|------|------|
| LightSail ($5プラン) | 750円 |
| Translation API | 0円（無料枠） |
| ドメイン | 125円 |
| **合計** | **875円** |

#### マルチテナント（10テナント想定）

| 項目 | 月額 | 備考 |
|------|------|------|
| LightSail ($10プラン) | 1,500円 | 2GB RAM, 2 vCPU |
| Translation API | 0円 | テナントごとに無料枠 |
| ドメイン | 125円 | ワイルドカードDNS |
| Redis (ElastiCache) | 3,000円 | オプション |
| **合計** | **1,625円〜4,625円** | Redis次第 |

#### マルチテナント（50テナント想定）

| 項目 | 月額 | 備考 |
|------|------|------|
| LightSail ($20プラン) | 3,000円 | 4GB RAM, 2 vCPU |
| Translation API | 0円 | 無料枠内 |
| ドメイン | 125円 | - |
| Redis (ElastiCache) | 3,000円 | 必須 |
| **合計** | **6,125円** | - |

### 12.2 スケーリング戦略

| テナント数 | 推奨構成 | 月額コスト |
|-----------|----------|-----------|
| 1-5 | LightSail $5 | 875円 |
| 6-20 | LightSail $10 + Redis | 4,625円 |
| 21-50 | LightSail $20 + Redis | 6,125円 |
| 51-100 | LightSail $40 + Redis | 9,125円 |
| 100+ | AWS EC2 + RDS + ElastiCache | 要見積もり |

### 12.3 収益モデル例

| プラン | 月額料金 | 機能 | 目標テナント数 |
|--------|---------|------|---------------|
| FREE | 0円 | 基本機能のみ | 無制限 |
| BASIC | 5,000円 | 全機能 + サポート | 20 |
| PREMIUM | 10,000円 | カスタマイズ + 優先サポート | 10 |

**収益試算（30テナント）:**
- FREE: 10テナント × 0円 = 0円
- BASIC: 15テナント × 5,000円 = 75,000円
- PREMIUM: 5テナント × 10,000円 = 50,000円
- **合計: 125,000円/月**

**利益:**
- 収益: 125,000円
- インフラコスト: 6,125円
- **粗利: 118,875円/月**

---

## 13. まとめ

### 13.1 マルチテナント化のメリット

✅ **スケーラビリティ**
- 新規テナントの追加が容易
- 他のマンション・コミュニティへの横展開

✅ **コスト効率**
- 共通インフラで運用コストを最小化
- スケールメリットによる開発効率化

✅ **保守性**
- 単一コードベースで全テナント管理
- バグ修正・機能追加が一度で完了

✅ **ビジネス拡張性**
- SaaSモデルへの移行が可能
- 収益化の選択肢が広がる

### 13.2 実装の優先順位

| フェーズ | 内容 | 期間 |
|---------|------|------|
| **Phase 1** | 基盤実装（スキーマ、ミドルウェア、認証） | 2-3週間 |
| **Phase 2** | 既存機能の対応 | 2-3週間 |
| **Phase 3** | テナント管理機能 | 1-2週間 |
| **Phase 4** | セキュリティ・パフォーマンス | 1週間 |
| **Phase 5** | 本番移行 | 1週間 |

**合計: 7-10週間**

### 13.3 次のアクション

1. ✅ マルチテナント設計の承認
2. ⬜ 開発環境でのPrismaスキーマ拡張
3. ⬜ ミドルウェアの実装とテスト
4. ⬜ 既存機能のテナント対応
5. ⬜ テナント管理機能の実装
6. ⬜ 本番移行計画の詳細化

---

**文書管理番号:** SEC-APP-MULTI-TENANT-001  
**承認者:** ____________________  
**日付:** ____________________
